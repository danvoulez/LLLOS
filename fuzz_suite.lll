###############################################################################
module fuzz_suite
version: "0.1.0"

import identity_auth_service.*
import enforcement_policy.*
import rules_engine.*

###############################################################################
fuzz id_fuzz
cases: 500
inputs:
  - label   : rnd.string(3,10, [a-z])
  - payload : rnd.bytes(32)
body:
  # cria nova identidade PERSON
  - let id = create_identity(label = inputs.label).id
  - let sig = sign_ed25519(derive_private_key(id), inputs.payload)
  # verificação deve ser true
  - let ok = verify_signature(
              id           = id,
              message_b64  = base64_url_encode(inputs.payload),
              signature_b64= base64_url_encode(sig)
            ).valid
  - assert ok == true
  # garantia: id é único
  - assert count LogLineID[value = id] == 1

###############################################################################
# cria policy fixa (1000/day) antes de fuzz  ➜ setup
###############################################################################
setup quota_fuzz:
  - if !exists quota_policy[tenant_id="fuzz", scope="api"]:
      insert quota_policy {
        id:uuid_v7(), tenant_id:"fuzz", scope:"api",
        limit:1000, period:"DAY"
      }

fuzz quota_fuzz
cases: 10_000
inputs: { amount: rnd.int(1,3) }
body:
  - let res = enforce_quota("fuzz","api",inputs.amount)
  # leitura imediata do uso
  - let usage = query quota_usage[
      policy_id in (select id from quota_policy where tenant_id="fuzz" and scope="api"),
      window_start = date_trunc("day", now())
    ][0]
  # invariantes
  - assert usage.used <= 1000 or res.allowed == false
  - assert usage.used <= 1001          # nunca passa > limite+1 (raça)

###############################################################################
# fuzz em parser/avaliador de regras
###############################################################################
setup rules_fuzz:
  - if !exists rule[name="echo"]:
      insert rule {
        id:uuid_v7(), name:"echo", expr:"foo == foo", action:"notify.ops"
      }

fuzz rules_fuzz
cases: 200
inputs:
  - expr : rnd.choice([
      "x > 10 && y < 5",
      "!(flag) || score >= 100",
      "country == 'PT'",
      "amount / 2 == 5",
      "a == b && b == c"
    ])
  - x    : rnd.int(0,20)
  - y    : rnd.int(0,20)
  - flag : rnd.bool()
  - score: rnd.int(0,200)
  - amount: rnd.int(0,20)
body:
  # regra ad-hoc
  - let r = { id: uuid_v7(), name:"dyn", expr:inputs.expr, action:"notify.ops", enabled:true }
  - let ctx = { x:inputs.x, y:inputs.y, flag:inputs.flag,
                score:inputs.score, country:"PT", amount:inputs.amount,
                a:1, b:1, c:1 }
  - let res1 = rules_engine.run_rule(r, ctx).matched
  - let res2 = rules_engine.parse_expr(r.expr, ctx).result
  - assert res1 == res2              # coerência run_rule vs parse_expr
